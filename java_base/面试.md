****

# 1. 线程池的分类

![img](https://img2023.cnblogs.com/blog/309403/202303/309403-20230315151612283-1261021394.png)

## 1.1 newCachedThreadPool

创建一个可进行缓存重复利用的线程池

## 1.2 newFixedThreadPool

创建一个可重复固定线程的线程池，以共享的无界队列方式来运行这些线程，线程池处于一定的量，可以很好的控制线程的并发量

## 1.3 newSingleThreadExecutor

创建一个使用单个worker线程的executor，以无界队列方式来运行该线程，线程池中最多执行一个线程，之后提交的线程会排在队列中以此执行

## 1.4 newScheduledThreadPool

创建一个线程池，它可安排给延迟后运行命令或者定期执行

## 1.5 newWorkSteanlingPool

创建一个带并行级别的线程，并行级别决定了同一时刻最多有多少个线程在执行，如不传并行级别参数，将默认当前系统的cpu个数

# 2. gc垃圾回收
JVM的垃圾回收动作可以大致分为两大步，**如何发现垃圾**、**如何回收垃圾**。线程私有的不存在垃圾回收，只有线程共享的才会存在垃圾回收，所以堆中存在垃圾回收。

## 2.1 如何发现垃圾
java 语言规范并没有明确说明JVM使用的哪种垃圾回收算法，但是常见的垃圾回收算法有两种，引用计数和根搜索算法
### 2.1.1 引用算法
堆中的对象每次被引用一次，则计数器加1，每减少一次引用就减1，当对象的引用计数器为0时，可以被当作垃圾收集：
    - 优点：块
    - 缺点： 无法检测出循环引用。如两个对象互相引用时，他们的引用计数永远不可能为0
### 2.1.2  根搜索算法（也叫可达性分析）
根搜索算法是把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即可以当作垃圾。
