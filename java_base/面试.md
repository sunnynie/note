****

# 1. 线程池的分类

![img](https://img2023.cnblogs.com/blog/309403/202303/309403-20230315151612283-1261021394.png)

## 1.1 newCachedThreadPool

创建一个可进行缓存重复利用的线程池

## 1.2 newFixedThreadPool

创建一个可重复固定线程的线程池，以共享的无界队列方式来运行这些线程，线程池处于一定的量，可以很好的控制线程的并发量

## 1.3 newSingleThreadExecutor

创建一个使用单个worker线程的executor，以无界队列方式来运行该线程，线程池中最多执行一个线程，之后提交的线程会排在队列中以此执行

## 1.4 newScheduledThreadPool

创建一个线程池，它可安排给延迟后运行命令或者定期执行

## 1.5 newWorkSteanlingPool

创建一个带并行级别的线程，并行级别决定了同一时刻最多有多少个线程在执行，如不传并行级别参数，将默认当前系统的cpu个数

# 2. gc垃圾回收
JVM的垃圾回收动作可以大致分为两大步，**如何发现垃圾**、**如何回收垃圾**。线程私有的不存在垃圾回收，只有线程共享的才会存在垃圾回收，所以堆中存在垃圾回收。

## 2.1 如何发现垃圾
java 语言规范并没有明确说明JVM使用的哪种垃圾回收算法，但是常见的垃圾回收算法有两种，引用计数和根搜索算法
### 2.1.1 引用算法
堆中的对象每次被引用一次，则计数器加1，每减少一次引用就减1，当对象的引用计数器为0时，可以被当作垃圾收集：
    - 优点：块
    - 缺点： 无法检测出循环引用。如两个对象互相引用时，他们的引用计数永远不可能为0
### 2.1.2  根搜索算法（也叫可达性分析）
根搜索算法是把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即可以当作垃圾。

# 3. 重载和重写的区别
## 3.1 重载
发生在同一个类中，方法名必须相同，参数类型不同，个数不同的顺序不同，方法返回
## 3.2 重写
发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出异常

    访问修饰符范围小于等于父类，如果父类方法访问修饰符为private，则子类就不同重写该方法
    
# 4. String ,StringBuffer,StringBuilder三者之间的区别
- String 是字节常量，fianl修饰 
- StringBuffer 字符串变量（线程安全）
- StringBuffer 字符串变量（线程不安全）
## String 和StringBuffer
1. String 和StringBuffer 主要区别是性能： String 是不可变对象，每次对String类型操作都等同于产生了一个新的String 对象，然后指向新的String对象，所以尽量不在对String进行大量的拼接操作，否则会产生很多临时的对象，导致GC开始工作，影响系统的性能。
2. StringBuffer是对象本身操作，而不是产生新的对象，因此在有多个拼接情况下，我们建议使用StringBuffer.
3. VM会对String 拼接做一定的优化，String s="This is only"+" this".优化成单个字符串

## StringBuffer 和StringBuilder
StringBuffer 是线程安全的可变字符串，其内部实现的是可变数组。StringBuilder是jdk1.5新增的，其功能和StringBuffer 类似，但是非线程安全的，因此，在很多线程问题的前提下，使用StringBuilder会有更好的性能