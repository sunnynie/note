# 同步锁、死锁、乐观锁、悲观锁
## 同步锁
当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种情况出现，我们保证线程同步互斥，就是指并发执行的多个线程，在同一个时间内只允许一个线程访问共享的数据。java中可以使用synchronized关键字获取到一个对象的同步锁
## 死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放
## 乐观锁
总是假设最好的情况，每次拿数据的时候都任务别人不会修改，所以不会上锁，但是在更新的时候会判断一下此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用场景，这样可以提高吞吐量，像数据库提供的类似于write_conditio机制，其实都是提供乐观锁.在java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的
## 悲观锁
总是假设最坏的情况，每次去拿数据都认为别人会修改数据，所以每次都在拿数据的时候会上锁，这样别人想拿这个数据会阻塞知道它拿到锁（共享资源每次会给一个线程使用，其他线程阻塞，用完这个资源转让给其他线程）。传统的关系型数据库里面就用到了很多这种的锁的机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。java中synchronized和reetrantLock等独占锁就是悲观锁思想的实现


# 乐观锁详解
乐观锁是一种基于数据版本控制的并发控制方式，在并发环境下，通过对数据版本进行比较，从而实现数据的正确并发访问。常见的实现方式有以下两种：

1. 版本号机制：在数据表中增加一个版本号字段，当数据被修改时，版本号加1。在更新数据时，比较当前数据的版本号和数据库中的版本号是否一致，若一致，则执行更新操作并将版本号加1；若不一致，则说明数据已被其他线程修改，需要进行回滚操作或者抛出异常。

2. 时间戳机制：在数据表中增加一个时间戳字段，记录每次数据的修改时间。在更新数据时，比较当前数据的时间戳和数据库中的时间戳是否一致，若一致，则执行更新操作；若不一致，则说明数据已被其他线程修改，需要进行回滚操作或者抛出异常。

乐观锁的优点是不需要进行加锁操作，避免了因加锁带来的性能损失和死锁等问题。但是，在并发量较大的情况下，由于需要频繁地进行版本号或时间戳的比较，可能会导致大量的冲突和回滚操作，从而影响系统的性能。因此，在实际应用中，需要根据具体的业务场景选择合适的并发控制策略。
# 悲观锁详解
