## mysql 中事务隔离性

在mysql中事务隔离级别分为4类:

- 提交未读(read uncommitted)
- 提交已读(read committed)
- 可重复读(repeatable read)
- 序列化(serializable)

mysql默认的事务隔离级别是可重复读(repeatable read),这4中隔离级别的说明如下:

### read uncommitted

读未提交,也叫未提交读,该隔离级别的事务可以看到其他的事务中未提交的数据.该隔离级别因为可以读取其他的事务中未提交的数据,而不提交的数据可能会发生回滚.因此我们把该级别的数据称之为脏数据,把这个问题称为脏读.

### read committed

读已提交,也叫提交读.该隔离级别的事务可以读取已经提交的数据.因此它不不会出现脏数据问题.但由于在事务的执行中可以读取到其他的事务提交的数据,所以在不同时间的相同sql查询中,可能会得到不同的结果,这种现象叫做不可重复读.

### repeatable read

可重复读,是mysql 默认的事务隔离级别,它能确保同一个事务多次查询的结果一致.但是也会有新的问题,比如这个级别的事务正在执行时,另外一个事务成功的插入了某条数据,但因为它每次查询的结果都是一样的,所以会导致查询不到这条数据,自己重复插入时又失败(因为唯一索引约束的原因).明明在事务中查询不到这条数据,但自己就是插入进去了,这就要幻读(phantom read).

### searializable

序列化,事务最高的隔离级别,它会强制事务排序,使它不会发生冲突,从而解决了脏数据,不可重复度和幻读的问题,但是因为执行效率太低,所以真正的场景不多.

## 总结一下,mysql的4种事务隔离级别对应脏读,不可重复读和幻读的关系图如下:

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | :--------: | ---- |
| 读未提交     | O    |     O     | O    |
| 读已提交     | X    |     O     | O    |
| 可重复读     | X    |     X     | O    |
| 串行话       | X    |     X     | X    |
